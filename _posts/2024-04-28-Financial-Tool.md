---
layout: default
title:  金融工具
--- 

### 功能简述

一个融工具有多种定价方式，价格由输入数据决定，数据随时间变化，而且可能有不同的来源。市场数据由不同的来源提供，工具需要能够保持与数据源的联系，以便在数据变化时进行更新。
处理输入数据：采用观察者模式，金融工具是观察者，输入数据是被观察者，只要输入数据改变，金融工具就会收到通知。处理数据的过程参考QuantLib库中的Handle类，它就像一个电视遥控器，帮你控制电视，而你可以不用知道中间都是怎么实现的。
业务类采用懒加载设计，通过QuantLib库的LazyObject类实现，懒加载就是每次只处理部分缓存数据。

### 代码框架：

被观察者（Observable）：存在一个或多个观察者对象 对 被观察者对象的状态进行监视，当被观察者对象状态发生变化，所有的观察者对象都会被通知
set_type observers_ :是一个集合<set>，用来存所有 “观察当前被观察者对象的观察者对象”；类型为Observer*，即观察者对象的指针
notifyObservers() : 用于通知所有观察者对象。
观察者（Observer）：观察者对象会监视一个或多个被观察者对象的状态。当被观察者对象的状态发生变化时，观察者对象会被通知，然后更新自身的状态。
懒加载模式：继承了观察者和被观察者类，所以它既可以作为观察者，也可以作为被观察者：类的特点是延迟计算：它不会立即对观察到的变化作出响应，而是会缓存计算结果，在必要的时候才重新计算
*update()：这个函数覆盖了其父类Observer的update()函数。在观察到变化时，它不会立即重新计算，而是将calculated_设置为false，表示需要重新计算。然后，如果它不是冻结状态，它会通知所有观察它的观察者。
*freeze()和unfreeze()：这两个函数用于锁定和解锁对象。当对象被冻结（frozen_为true）时，即使观察到了变化，它也不会通知观察它的观察者。
*recalculate()和calculate()：这两个函数用于计算或重新计算结果。recalculate()函数会强制重新计算结果，而calculate()函数则实现了懒加载：如果已经计算过了（calculated_为true），且对象没有被冻结（frozen_为false），就不进行计算。
*performCalculations()：这是一个纯虚函数，需要在子类中实现。这个函数应该包含真正的业务逻辑。
*calculated_、frozen_和alwaysForward_是类的保护成员，用来控制计算的行为。calculated_表示结果是否已经被计算过，frozen_表示对象是否被冻结，alwaysForward_表示是否总是转发通知。
*Instrument类继承了LazyObject类，这个类可以代表一种具体的金融工具。它需要实现performCalculations()函数以提供真正的计算逻辑。

### 总结：

1.LazyObject::update方法不会直接调用LazyObject::calculate方法。当被观察的对象改变时，它只负责标记LazyObject对象需要进行重新计算，并且如果开启了监视传递的开关，就会向观察自己的观察者们发送通知。
2.在这种设计中，真正的计算是由观察者在收到通知后，通过调用LazyObject对象的calculate方法或者其他类似的方法来执行的。这样，LazyObject对象能够实现延迟计算，也就是只有当结果真正需要的时候才进行计算，从而提高效率。
3.LazyObject::calculate方法的设计也很巧妙。如果既没有计算过，也没有被冻结，那么就会执行真正的计算。而且，为了防止在进行计算时发生的异常导致无限递归，计算的开始会先将calculated_设置为true，然后才真正执行计算。如果计算过程中发生异常，那么就会将calculated_设置回false，然后将异常抛出。
这是一种非常有用的设计模式，特别是在计算成本较高或者结果并不总是需要的情况下。
代码很好地解决了在多线程环境中潜在的并发问题，特别是在防止递归更新和无限循环更新方面。
这段代码中的UpdateChecker是LazyObject类的一个私有内部类，它的作用是在LazyObject对象更新时避免重入。当创建UpdateChecker对象时，它会将它的LazyObject对象的updating_标志设置为true，当UpdateChecker对象销毁时，它会将LazyObject对象的updating_标志设置回false。
在LazyObject::update方法中，首先检查updating_标志。如果为true，表示该LazyObject对象已经在更新中，直接返回，防止了重入和无限循环。然后创建一个UpdateChecker对象，进入更新过程。无论更新过程是否成功，一旦退出更新过程，UpdateChecker对象就会被销毁，从而自动将updating_标志设置回false。
这种设计方法巧妙地利用了C++的对象生命周期和作用域规则，避免了在多线程环境下的并发问题，增强了代码的鲁棒性。


### Question & Answer
Q:我选择卷积神经网络，pyTorch深度学习框架，然后我的图像数据已经准备好了，告诉我怎样做才能最快开始训练，怎么搭建框架
A:既然你已经选择了卷积神经网络（CNN）和PyTorch框架，并且已经准备好了图像数据，那么你可以按照以下步骤进行操作：
安装PyTorch库：首先，你需要在你的机器上安装PyTorch库。你可以访问PyTorch官网，在上面找到适合你的操作系统和Python版本的安装指南。
数据预处理：PyTorch提供了一些工具来帮助你加载和预处理图像数据。你可以使用torchvision.datasets模块来加载数据，使用torchvision.transforms模块来预处理数据。
定义神经网络模型：你可以使用PyTorch的torch.nn模块来定义你的神经网络模型。对于卷积神经网络，你可能需要使用nn.Conv2d、nn.MaxPool2d、nn.ReLU、nn.Linear等类。
定义损失函数和优化器：你需要选择一种损失函数来衡量模型的预测结果和真实结果的差距。对于分类问题，常用的损失函数有交叉熵损失nn.CrossEntropyLoss等。你还需要选择一种优化算法来更新模型的参数。常用的优化算法有随机梯度下降torch.optim.SGD、Adamtorch.optim.Adam等。
训练模型：你需要编写一个循环来反复训练你的模型。在每次循环中，你需要执行以下步骤：计算模型的预测结果、计算损失、使用backward()函数计算梯度、使用优化器更新模型参数、清除梯度。
评估模型：你可以使用验证集来评估模型的性能。你需要编写一个循环来计算模型在验证集上的预测结果，并计算准确率等指标。
保存和加载模型：在训练过程中，你可能需要定期保存模型的状态，以便在训练中断后可以从断点处继续训练。你可以使用torch.save()函数来保存模型，使用torch.load()函数来加载模型。
以上是训练卷积神经网络的大体步骤。在实际操作中，每一步都有很多细节需要注意。你可能需要查阅更多的PyTorch教程或文档，以获取更详细的信息